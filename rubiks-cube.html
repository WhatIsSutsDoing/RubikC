<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik's Cube</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
  :root {
    --bg:     #080c14;
    --panel:  #0e1520;
    --border: #1e2d45;
    --text:   #c8d8f0;
    --dim:    #4a6080;
    --glow:   #3a7fff;
  }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    display: flex;
    flex-direction: column;
    height: 100svh;
    overflow: hidden;
  }
  body::before {
    content: '';
    position: fixed; inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.04) 2px, rgba(0,0,0,0.04) 4px);
    pointer-events: none;
    z-index: 10;
  }
  header {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 14px;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
    position: relative;
  }
  .logo-cubes {
    display: grid;
    grid-template-columns: repeat(3,7px);
    grid-template-rows: repeat(3,7px);
    gap: 1.5px;
  }
  .logo-cubes span { border-radius: 1px; display: block; }
  h1 {
    font-family: 'Orbitron', sans-serif;
    font-weight: 900;
    font-size: clamp(0.9rem, 3vw, 1.3rem);
    letter-spacing: 6px;
    text-transform: uppercase;
  }
  .drag-label {
    position: absolute; right: 16px;
    font-size: 0.55rem; letter-spacing: 2px;
    color: var(--dim); text-transform: uppercase;
  }
  #canvas-container {
    flex: 1;
    min-height: 0;
    cursor: grab;
    user-select: none;
  }
  #canvas-container:active { cursor: grabbing; }
  #canvas-container canvas { display: block; }
  #controls {
    flex-shrink: 0;
    background: var(--panel);
    border-top: 1px solid var(--border);
    padding: 10px 12px 13px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }
  .moves-grid {
    display: grid;
    grid-template-columns: repeat(4,1fr);
    gap: 8px;
    width: 100%;
    max-width: 500px;
  }
  .move-col { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .move-label { font-size: 0.55rem; letter-spacing: 2px; text-transform: uppercase; color: var(--dim); }
  .btn-pair { display: flex; gap: 5px; width: 100%; }
  .btn {
    flex: 1;
    border: none; border-radius: 5px;
    padding: 10px 4px;
    cursor: pointer;
    font-family: 'Space Mono', monospace;
    font-size: clamp(0.65rem, 2vw, 0.78rem);
    font-weight: 700;
    transition: transform 0.08s, filter 0.1s;
    position: relative; overflow: hidden;
  }
  .btn::after {
    content: ''; position: absolute; inset: 0;
    background: rgba(255,255,255,0.1); opacity: 0;
    transition: opacity 0.1s;
  }
  .btn:hover::after { opacity: 1; }
  .btn:active { transform: scale(0.92); filter: brightness(0.85); }
  .btn-u { background: #1e5c3a; color: #7dffc0; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.35); }
  .btn-r { background: #1a3c7a; color: #7dbfff; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.35); }
  .btn-l { background: #7a2c14; color: #ffaa77; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.35); }
  .btn-f { background: #4a3a10; color: #ffd966; box-shadow: inset 0 -2px 0 rgba(0,0,0,0.35); }
  .divider { width: 100%; max-width: 500px; height: 1px; background: var(--border); }
  #btn-scramble {
    width: 100%; max-width: 500px;
    padding: 12px 0;
    background: #111c2e;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--text);
    font-family: 'Orbitron', sans-serif;
    font-weight: 700;
    font-size: clamp(0.7rem, 2vw, 0.9rem);
    letter-spacing: 4px;
    text-transform: uppercase;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
  }
  #btn-scramble:hover { background: #1a2d50; border-color: var(--glow); box-shadow: 0 0 14px rgba(58,127,255,0.3); }
  #btn-scramble:active { transform: scale(0.98); }
</style>
</head>
<body>

<header>
  <div class="logo-cubes" id="logoCubes"></div>
  <h1>Rubik's Cube</h1>
  <span class="drag-label">Drag to orbit</span>
</header>

<div id="canvas-container"></div>

<div id="controls">
  <div class="moves-grid">
    <div class="move-col">
      <span class="move-label">Top</span>
      <div class="btn-pair">
        <button class="btn btn-u" onclick="doMove('U')" title="U">U</button>
        <button class="btn btn-u" onclick="doMove('UP')" title="U′">U′</button>
      </div>
    </div>
    <div class="move-col">
      <span class="move-label">Right</span>
      <div class="btn-pair">
        <button class="btn btn-r" onclick="doMove('R')" title="R – right layer up">R↑</button>
        <button class="btn btn-r" onclick="doMove('RP')" title="R′ – right layer down">R↓</button>
      </div>
    </div>
    <div class="move-col">
      <span class="move-label">Left</span>
      <div class="btn-pair">
        <button class="btn btn-l" onclick="doMove('L')" title="L – left layer down">L↓</button>
        <button class="btn btn-l" onclick="doMove('LP')" title="L′ – left layer up">L↑</button>
      </div>
    </div>
    <div class="move-col">
      <span class="move-label">Front</span>
      <div class="btn-pair">
        <button class="btn btn-f" onclick="doMove('F')" title="F – clockwise">F↺</button>
        <button class="btn btn-f" onclick="doMove('FP')" title="F′ – counter-clockwise">F↻</button>
      </div>
    </div>
  </div>
  <div class="divider"></div>
  <button id="btn-scramble" onclick="scramble()">⟳ &nbsp;Scramble</button>
</div>

<script>
// ══════════════════════════════════════════════════════════════════
//  CUBE STATE
//  Faces:  U=0  D=1  F=2  B=3  L=4  R=5
//  Each face: 9 colour values [0..5], one per sticker.
//
//  Sticker index layout (viewed face-on):
//      0 1 2
//      3 4 5
//      6 7 8
//
//  Grid coordinate mappings (gx,gy,gz ∈ {-1,0,1}):
//    U[i]: gx=i%3-1,  gy=+1,       gz=floor(i/3)-1
//    D[i]: gx=i%3-1,  gy=-1,       gz=floor(i/3)-1
//    F[i]: gx=i%3-1,  gy=1-floor(i/3), gz=+1
//    B[i]: gx=1-(i%3),gy=1-floor(i/3), gz=-1   (X mirrored)
//    R[i]: gx=+1,     gy=1-floor(i/3), gz=1-(i%3)
//    L[i]: gx=-1,     gy=1-floor(i/3), gz=i%3-1
// ══════════════════════════════════════════════════════════════════
const FU=0,FD=1,FF=2,FB=3,FL=4,FR=5;

let state;
function initState() {
  state = Array.from({length:6}, (_,i) => Array(9).fill(i));
}

function rotateCW(f) {
  const s=state[f], t=[...s];
  s[0]=t[6];s[1]=t[3];s[2]=t[0];
  s[3]=t[7];s[4]=t[4];s[5]=t[1];
  s[6]=t[8];s[7]=t[5];s[8]=t[2];
}
function rotateCCW(f) {
  const s=state[f], t=[...s];
  s[0]=t[2];s[1]=t[5];s[2]=t[8];
  s[3]=t[1];s[4]=t[4];s[5]=t[7];
  s[6]=t[0];s[7]=t[3];s[8]=t[6];
}

// 4-cycle: a[ai] → b[bi] → c[ci] → d[di] → a[ai]
function cyc(a,ai,b,bi,c,ci,d,di) {
  const t=state[a][ai];
  state[a][ai]=state[d][di];
  state[d][di]=state[c][ci];
  state[c][ci]=state[b][bi];
  state[b][bi]=t;
}

// ── U: rotate top layer clockwise (viewed from above) ────────────
//  Cycle direction: F→L→B→R→F  (CW from above)
//  F[0,1,2] → L[0,1,2] → B[0,1,2] → R[0,1,2] → F[0,1,2]
//  Wait—standard: U-CW: F→R→B→L→F for the top stickers.
//  Correct standard notation: U moves top layer so that
//    front-row of U goes to right-side after CW rotation.
//    F top row → R top row → B top row → L top row
//  Edge stickers: F[0,1,2] → R[0,1,2] → B[0,1,2] → L[0,1,2]
function applyU() {
  rotateCW(FU);
  for(let i=0;i<3;i++) cyc(FF,i, FR,i, FB,i, FL,i);
}
function applyUP() {
  rotateCCW(FU);
  for(let i=0;i<3;i++) cyc(FL,i, FB,i, FR,i, FF,i);
}

// ── R: rotate right layer ─────────────────────────────────────────
//  R[i] stickers where gx=+1. Column gz goes 1→0→-1 as sticker i col goes 0→1→2.
//  Cubies in right column at (gx=1, gy=1,0,-1, gz=1,0,-1).
//  CW (looking from right, +X): top front → top → top back → bottom back → etc.
//  Actually R-CW means: F right column goes up, U right column goes to back, etc.
//  Standard: R CW: F col2 → U col2 → B col0(rev) → D col2 → F col2
//  Sticker triples:
//    F[2,5,8] → U[2,5,8] → B[6,3,0] → D[2,5,8]
function applyR() {
  rotateCW(FR);
  cyc(FF,2, FU,2, FB,6, FD,2);
  cyc(FF,5, FU,5, FB,3, FD,5);
  cyc(FF,8, FU,8, FB,0, FD,8);
}
function applyRP() {
  rotateCCW(FR);
  cyc(FD,2, FB,6, FU,2, FF,2);
  cyc(FD,5, FB,3, FU,5, FF,5);
  cyc(FD,8, FB,0, FU,8, FF,8);
}

// ── L: rotate left layer ─────────────────────────────────────────
//  L CW (looking from left, -X): F left col goes down
//  Standard: L CW: F col0 → D col0 → B col2(rev) → U col0 → F col0
//  Sticker triples:
//    F[0,3,6] → D[0,3,6] → B[8,5,2] → U[0,3,6]
function applyL() {
  rotateCW(FL);
  cyc(FF,0, FD,0, FB,8, FU,0);
  cyc(FF,3, FD,3, FB,5, FU,3);
  cyc(FF,6, FD,6, FB,2, FU,6);
}
function applyLP() {
  rotateCCW(FL);
  cyc(FU,0, FB,8, FD,0, FF,0);
  cyc(FU,3, FB,5, FD,3, FF,3);
  cyc(FU,6, FB,2, FD,6, FF,6);
}

// ── F: rotate front face ─────────────────────────────────────────
//  F CW (looking at front, +Z): U bottom row → R left col → D top row → L right col
//  Standard: F CW: U[6,7,8] → R[0,3,6] → D[2,1,0] → L[8,5,2]
function applyF() {
  rotateCW(FF);
  cyc(FU,6, FR,0, FD,2, FL,8);
  cyc(FU,7, FR,3, FD,1, FL,5);
  cyc(FU,8, FR,6, FD,0, FL,2);
}
function applyFP() {
  rotateCCW(FF);
  cyc(FL,2, FD,0, FR,6, FU,8);
  cyc(FL,5, FD,1, FR,3, FU,7);
  cyc(FL,8, FD,2, FR,0, FU,6);
}

const MOVE_FNS = {
  U:applyU, UP:applyUP,
  R:applyR, RP:applyRP,
  L:applyL, LP:applyLP,
  F:applyF, FP:applyFP
};

function doMove(name) {
  MOVE_FNS[name]();
  updateVisual();
}

function scramble() {
  initState();
  const keys = Object.keys(MOVE_FNS);
  let last = -1;
  for(let i=0;i<24;i++) {
    let idx;
    do { idx = Math.floor(Math.random()*keys.length); } while(idx===last);
    last = idx;
    MOVE_FNS[keys[idx]]();
  }
  updateVisual();
}

// ══════════════════════════════════════════════════════════════════
//  THREE.JS 3D RENDERER
// ══════════════════════════════════════════════════════════════════
const FACE_COLORS = [
  0xf5f5f5,  // U – white
  0xffd700,  // D – yellow
  0xdd2222,  // F – red
  0xff7700,  // B – orange
  0x229944,  // L – green
  0x2266ee,  // R – blue
];
const INNER = 0x080c14;

const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x080c14);

const camera = new THREE.PerspectiveCamera(42, 1, 0.1, 100);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const key = new THREE.DirectionalLight(0xffe8cc, 0.65);
key.position.set(4, 6, 5);
scene.add(key);
const fill = new THREE.DirectionalLight(0x99ccff, 0.3);
fill.position.set(-4, -2, 3);
scene.add(fill);

// Orbit state
let theta = 0.55, phi = 1.1, radius = 6.2;
function camUpdate() {
  camera.position.set(
    radius * Math.sin(phi) * Math.sin(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.cos(theta)
  );
  camera.lookAt(0,0,0);
}
camUpdate();

// Drag orbit
let dragging=false, lx=0, ly=0;
container.addEventListener('mousedown', e=>{dragging=true;lx=e.clientX;ly=e.clientY;});
window.addEventListener('mouseup', ()=>dragging=false);
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  theta -= (e.clientX-lx)*0.012;
  phi   -= (e.clientY-ly)*0.012;
  phi = Math.max(0.1, Math.min(Math.PI-0.1, phi));
  lx=e.clientX; ly=e.clientY;
  camUpdate();
});
container.addEventListener('touchstart', e=>{
  dragging=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY;
  e.preventDefault();
},{passive:false});
window.addEventListener('touchend', ()=>dragging=false);
window.addEventListener('touchmove', e=>{
  if(!dragging) return;
  theta -= (e.touches[0].clientX-lx)*0.014;
  phi   -= (e.touches[0].clientY-ly)*0.014;
  phi = Math.max(0.1, Math.min(Math.PI-0.1, phi));
  lx=e.touches[0].clientX; ly=e.touches[0].clientY;
  camUpdate();
},{passive:false});

// Build 27 cubies
// BoxGeometry face material order: +X=0, -X=1, +Y=2, -Y=3, +Z=4, -Z=5
//   → R=0, L=1, U=2, D=3, F=4, B=5
const CUBIE_S = 0.91;
const geo = new THREE.BoxGeometry(CUBIE_S, CUBIE_S, CUBIE_S);

// cubies[gx+1][gy+1][gz+1]
const cubies = {};
for(let gx=-1; gx<=1; gx++)
  for(let gy=-1; gy<=1; gy++)
    for(let gz=-1; gz<=1; gz++) {
      const mats = Array.from({length:6}, ()=>
        new THREE.MeshLambertMaterial({color:INNER})
      );
      const mesh = new THREE.Mesh(geo, mats);
      mesh.position.set(gx, gy, gz);
      scene.add(mesh);
      cubies[`${gx},${gy},${gz}`] = mesh;
    }

// Given a face and sticker index, return the grid position and
// which BoxGeometry material slot (0-5 → R,L,U,D,F,B)
function stickerInfo(face, i) {
  const row=Math.floor(i/3), col=i%3;
  switch(face) {
    case FU: return {gx:col-1, gy:1,  gz:row-1,  slot:2};  // +Y
    case FD: return {gx:col-1, gy:-1, gz:row-1,  slot:3};  // -Y
    case FF: return {gx:col-1, gy:1-row, gz:1,   slot:4};  // +Z
    case FB: return {gx:1-col, gy:1-row, gz:-1,  slot:5};  // -Z  (X mirrored)
    case FR: return {gx:1,  gy:1-row, gz:1-col,  slot:0};  // +X
    case FL: return {gx:-1, gy:1-row, gz:col-1,  slot:1};  // -X
  }
}

function updateVisual() {
  // Reset all outer stickers to INNER first
  for(let gx=-1;gx<=1;gx++)
    for(let gy=-1;gy<=1;gy++)
      for(let gz=-1;gz<=1;gz++) {
        const m = cubies[`${gx},${gy},${gz}`].material;
        if(gx!==1)  m[0].color.setHex(INNER);
        if(gx!==-1) m[1].color.setHex(INNER);
        if(gy!==1)  m[2].color.setHex(INNER);
        if(gy!==-1) m[3].color.setHex(INNER);
        if(gz!==1)  m[4].color.setHex(INNER);
        if(gz!==-1) m[5].color.setHex(INNER);
      }

  // Paint from state
  for(let face=0; face<6; face++) {
    for(let i=0; i<9; i++) {
      const {gx,gy,gz,slot} = stickerInfo(face, i);
      cubies[`${gx},${gy},${gz}`].material[slot].color.setHex(FACE_COLORS[state[face][i]]);
    }
  }
}

// Resize handler
function onResize() {
  const w = container.clientWidth, h = container.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);
onResize();

// Animate
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// Logo mini-cube
(function buildLogo() {
  const el = document.getElementById('logoCubes');
  const colors = [
    '#dd2222','#ffd700','#2266ee',
    '#229944','#f5f5f5','#ff7700',
    '#dd2222','#2266ee','#229944'
  ];
  colors.forEach(c => {
    const s = document.createElement('span');
    s.style.background = c;
    el.appendChild(s);
  });
})();

// Init
initState();
updateVisual();
</script>
</body>
</html>
